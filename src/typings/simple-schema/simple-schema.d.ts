/**
 * Created by Dominik on 27.06.2015.
 *
 * Diese Definition ist nur provisorisch und ist unvollständig. Falls weitere Funktionen von SimpleSchema genutzt werden
 * sollen, müssen die dementsprechenden Methoden hier erst definiert werden.
 *
 * @see https://github.com/aldeed/meteor-simple-schema
 */


interface RegExPool {
    /**
    * For emails (uses a permissive regEx recommended by W3C, which most browsers use)
    */
    Email: RegExp;
    /**
    * For external domains and the domain only (requires a tld like .com)
    */
    Domain: RegExp;
    /**
    * For less strict domains and IPv4 and IPv6
    */
    WeakDomain: RegExp;
    /**
    * For IPv4 or IPv6
    */
    IP: RegExp;
    /**
    * For just IPv4
    */
    IPv4: RegExp;
    /**
    * For just IPv6
    */
    IPv6: RegExp;
    /**
    * For http, https and ftp urls
    */
    Url: RegExp;
    /**
    * For IDs generated by Random.id() of the random package, also usable to validate a relation id.
    */
    Id: RegExp;
    /**
    * For 5- and 9-digit US-ZIP codes
    */
    ZipCode: RegExp;
    WeakEmail: RegExp;
}

interface InvalidKey {
    /**
     * Name des Properties.
     */
    name: string;
    /**
     * Typ des Fehlers. Bsp: "required"
     */
    type: string;

}


interface SimpleSchemaValidationContext {
    validate(doc:any,options:any);
    resetValidation(): void;
    validateOne(doc:any, keyName:string, options?:any): boolean;
    isValid():boolean;
    invalidKeys(): Array<InvalidKey>;
    addInvalidKeys(invalidKeys: Array<InvalidKey>): void;
    keyIsInvalid(name: string): boolean;
    keyErrorMessage(name: string): string;
}


interface FieldDefinition {
    type: any;
    label?: string;
    optional?: boolean;
    minCount?: number;
    maxCount?: number;
    defaultValue?: any;
    regEx?: RegExp;
    autoValue?(): any;
    custom?():any;
    denyInsert?: boolean;
    allowedValues?: any[];
    max?: number;
    min?: number;
    trim?: boolean;
    blackbox?: boolean;
    unique?: boolean;
    requiredFor?: string;
    index?: number | boolean;
    autoform?: Object;
}

interface SchemaDefinition {
    [key: string] : FieldDefinition;
}

interface SimpleSchemaCleanOptions {
    filter?: boolean;
    autoConvert?: boolean;
    removeEmptyStrings?: boolean;
    trimStrings?: boolean;
    getAutoValues?: boolean;
    isModifier?: boolean;
    //extendAutoValueContext?: Object; brauch ma ned
}

interface CustomValidatorContext {
  /** The name of the schema key (e.g., "addresses.0.street") */
  key: string;
  /**  The generic name of the schema key (e.g., "addresses.$.street") */
  genericKey: string;
  /**  The field definition object. */
  definition: FieldDefinition;
  /**  Does the object being validated have this key set? */
  isSet: boolean;
  /**  The value to validate. */
  value: any;
  /**  The Mongo operator for which we're doing validation. Might be null. */
  operator: string;
  /**  Use this method to get information about other fields. */
  field: (fieldName:string) => CustomValidatorContext;
  /** Use this method to get information about other fields that have the same parent object. */
  siblingField: (fieldName:string) => CustomValidatorContext;

  isUpdate:boolean;
  isInsert:boolean;

  /** Unsets the value */
  unset: () => void;
}


declare class SimpleSchema {
    constructor(definition: SchemaDefinition);

    public static RegEx: RegExPool;

    public namedContext(nameOfContext?: string): SimpleSchemaValidationContext;
    public newContext(): SimpleSchemaValidationContext;
    public messages(errorMessages: any): void;
    public schema(key?: string): SchemaDefinition;
    public clean(doc:Object, options?:SimpleSchemaCleanOptions):void;

    public static messages(errorMessages: any): void;
    public static addValidator(validatorFunc: () => any): void;
    public static extendOptions(newOptions: any);
}
